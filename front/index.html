<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аудио Рекордер</title>
    <style>
        .bottom-nav {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #333;
            color: white;
            text-align: center;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            height: 50px; /* Установим фиксированную высоту панели */
            padding-bottom: 5vw; /* Уменьшим padding для компенсации выступающей кнопки */
            box-sizing: border-box;
        }

        .actions {
            margin-top: 20px;
            padding: 10px 15px;
            text-decoration: none;
            color: white;
            display: inline-block;
            flex-grow: 1;
            background-color: transparent;
            border: none; /* Add this line to remove borders */
        }

        .startRecord {
            border-radius: 50%; /* Круглая форма */
            width: 20vw; /* Уменьшим размеры кнопки, если это необходимо */
            height: 20vw;
            background-color: #4CAF50; /* Зеленый фон */
            color: white; /* Белый текст */
            border: none;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 24px;
            margin: 4px 2px;
            cursor: pointer;
            transition-duration: 0.4s;
            position: relative;
            bottom: 2.5vw; /* Меньшее выступание кнопки вниз */
            z-index: 1;
        }

        .startRecord:hover {
            background-color: #45a049; /* Изменение фона при наведении */
        }

        .recording {
            background-color: #FF0000; /* Красный фон */
            animation: blink 1s linear infinite;
        }

        .recording:hover {
            background-color: #B22222; /* Изменение фона при наведении */
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

    </style>
</head>
    <body>
        <div id="app">
            <ul>
                <li v-for="item in items.reverse()" :key="item.id">
                    {{ item.name }}
                    <button @click="delNeed(item.id)" class="send-button" >Del</button>
                </li>
            </ul>
            <div class="bottom-nav">
                <button @click="allNeeds()" class="actions" >List</button>
                <button @click="record()" id="startRecord" class="startRecord">REC</button>
                <button @click="clearNeeds()" class="actions" >Clear</button>
            </div>
        </div>

        <script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
        <script>
            const { createApp, ref } = Vue

            createApp({
                setup() {
                    const items = ref([])
                    let firstSupportedMimeType;
                    let microphone;
                    let recorder;

                    function clearNeeds() {
                        fetch("/needs", {
                            method: 'DELETE',
                        })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                items.value = [];
                            })
                            .then(data => console.log(data))
                            .catch(error => console.error('There was an error with the fetch operation: ', error));
                    }
                    function allNeeds() {
                        try {
                            // Fetch the data from the URL
                            fetch("/needs")
                                .then(response => response.json())
                                .then(data => {items.value = data})
                        } catch (error) {
                            console.error('There was an error with the fetch operation: ', error);
                        }
                    }
                    function delNeed(id) {
                        fetch('/needs/' + id, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json', // Тип содержимого, которое мы отправляем
                            },
                        })
                            .then(response => {
                                if (response.status === 200) {
                                    items.value = items.value.filter(item => item.id !== id)
                                }
                            })
                            .catch((error) => {
                                console.error('Error:', error); // Логируем возможную ошибку
                            });
                    }
                    function initStream() {
                        navigator.mediaDevices.getUserMedia({ audio: {echoCancellation:true} })
                            .then(stream => {
                                console.log('microphone access: success');
                                stream.stop()
                            })
                            .catch(error => {
                                console.error('Error accessing the microphone', error);
                            });
                    }
                    function sendAudioBlob(audioBlob) {
                        fetch('/needs', {
                            method: 'POST',
                            headers: {
                                'Content-Type': firstSupportedMimeType
                            },
                            body: audioBlob
                        })
                            .then(response => response.status)
                            .then(data => {
                                console.log('Успешная отправка:', data);
                            })
                            .catch(error => {
                                console.error('Ошибка отправки:', error);
                            });
                    }
                    function captureMicrophone(callback) {
                        if(microphone) {
                            callback(microphone);
                            return;
                        }

                        if(typeof navigator.mediaDevices === 'undefined' || !navigator.mediaDevices.getUserMedia) {
                            alert('This browser does not supports WebRTC getUserMedia API.');

                            if(!!navigator.getUserMedia) {
                                alert('This browser seems supporting deprecated getUserMedia API.');
                            }
                        }

                        navigator.mediaDevices.getUserMedia({
                            audio: isEdge ? true : {
                                echoCancellation: false
                            }
                        }).then(function(mic) {
                            callback(mic);
                        }).catch(function(error) {
                            alert('Unable to capture your microphone. Please check console logs.');
                            console.error(error);
                        });
                    }
                    function record() {
                        let btmRecord = document.getElementById('startRecord');
                        // Record audio
                        if (!microphone) {
                            captureMicrophone(function(mic) {
                                microphone = mic;

                                let options = {
                                    type: 'audio',
                                    numberOfAudioChannels: isEdge ? 1 : 2,
                                    checkForInactiveTracks: true,
                                    bufferSize: 16384
                                };

                                if(isSafari || isEdge) {
                                    options.recorderType = StereoAudioRecorder;
                                }

                                if(navigator.platform && navigator.platform.toString().toLowerCase().indexOf('win') === -1) {
                                    options.sampleRate = 48000; // or 44100 or remove this line for default
                                }

                                if(isSafari) {
                                    options.sampleRate = 44100;
                                    options.bufferSize = 4096;
                                    options.numberOfAudioChannels = 2;
                                }

                                if(recorder) {
                                    recorder.destroy();
                                    recorder = null;
                                }

                                recorder = RecordRTC(microphone, options);

                                recorder.startRecording();

                                btmRecord.classList.add('recording');
                                btmRecord.textContent = 'STOP';
                            });
                        } else {
                            recorder.stopRecording(function() {
                                let blob = recorder.getBlob();
                                sendAudioBlob(blob);
                                new Audio(URL.createObjectURL(blob)).play();

                                console.log('STOP STATE: ', recorder.state);
                                document.getElementById('startRecord').classList.remove('recording');
                                document.getElementById('startRecord').textContent = 'REC'

                                recorder.destroy();
                                recorder = null;

                                microphone.stop();
                                microphone = null;
                            });

                        }
                    }
                    function detectMimeType() {
                        function getAllSupportedMimeTypes(...mediaTypes) {
                            if (!mediaTypes.length) mediaTypes.push('audio');  // Задаем по умолчанию 'audio', если типы не указаны
                            const CONTAINERS = ['flac', 'm4a', 'mp3', 'mp4', 'mpeg', 'mpga', 'oga', 'ogg', 'wav', 'webm', 'not-supported'];

                            return CONTAINERS.flatMap(ext =>
                                mediaTypes.map(mediaType => `${mediaType}/${ext}`)
                            ).filter(variation => MediaRecorder.isTypeSupported(variation));  // Проверяем поддержку типов через MediaRecorder.isTypeSupported
                        }

                        const supportedMimeTypes = getAllSupportedMimeTypes('audio');  // Получаем поддерживаемые MIME-типы
                        console.log('Поддерживаемые MIME-типы для записи аудио без указания кодеков:', supportedMimeTypes);

                        // Устанавливаем глобальную переменную
                        firstSupportedMimeType = supportedMimeTypes.length > 0 ? supportedMimeTypes[0] : null;
                        console.log('Первый поддерживаемый MIME-тип:', firstSupportedMimeType);
                    }

                    allNeeds()
                    detectMimeType()
                    initStream()

                    return {
                        items,
                        clearNeeds,
                        allNeeds,
                        delNeed,
                        record
                    }
                }
            }).mount('#app')
        </script>
    </body>
</html>
